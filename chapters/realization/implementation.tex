\section{Implementation}\label{sec:implementation}

In this section, I describe in detail how features designed in chapter \ref{cptr:design} are actually implemented.
Sections are appropriately divided into parts according to the application where it was implemented.

\subsection{Initialize questionnaire migration}

The initialization part of the migration process is handled on both client and server side.
In the following sections, I will describe each part individually.

\subsubsection*{Server-side implementation}

On the server side, the initialization is an one step process.
The server expose and \gls{rest} \gls{api} route accessible on \route{POST /questionnaires/:qtnUuid/migrations} (described in \ref{sec:server-interface}).

The route is registered in shared application router using its \gls{url}, \gls{http} method and handling function.
The registration is shown in code example \ref{code:route-registration}.

\hscode{code:route-registration}{Registration of the \gls{rest} route}{route-registration.hs}

The initialization itself is simple, as it only requires to validate input data and store the migration state.
The state is a uncomplicated data structure which is composed from the migrated questionnaire (still based on the older version of the knowledge model) and identifier of the knowledge model.

Once the request pass validations, its data are passed are passed to \texttt{QuestionnaireMigrationService} module.
This module is resposinble for migration consistency -- it always transitions from one consisten state to another.

After the questionnaire is created, the stored data are enriched by compiled knowledge models and difference events and returned to the client.

By creating separate structure for keeping migration state, it is secured that the original version will never be modified during migration.
This approach is more complex than doing the state modification in-place (by modifying the original questionnaire directly), but significantly helps to keep system consistency.

\subsubsection*{Client-side implementation}

On the client side, this process requires two steps.
In the first step, the application needs to fetch informations about available knowledge models which user can migrate to.
This action is similar to upgrading knwoledge models itself and the whole code for such functionality was reused from existing code base (programmed by Ing. Jan Slifka\cite{mt-slifka}).

Once the data are fetched, the application will filter out invalid data (older versions of the knowledge model) and displays modal window with available options (shown in wireframe \ref{fig:wf1}).
Once the user selects version for migration the application sends data to the server.
After server responds, the application will load the migration detail and display it to the user.

The code used for transition between application states is shown in example \ref{code:create-migration}.

\elmcode{code:create-migration}{Transitioning between states during migration initialization}{create-migration.elm}

\subsection{Cancel questionnaire migration}

Now I would like acquaint the reader with implementatiton of the migration cancelling feature.

\subsubsection*{Server-side implementation}

On the server side, the cancellation is done by deleting existing questionnaire state.
By deleting initialized state, the original questionnaire will appear in exactly the same state as it was before the migration was initialized.

The endpoint is available at \route{DELETE /questionnaires/:qtnUuid/migrations} route.

Once the user sends request to the server, the it is validated by handler layer.
After validation, the data are processed using service which takes care of converting request data into internal representation.
The deletion itself is done using \texttt{DAO} as shown in example \ref{code:delete-dao}.

\hscode{code:delete-dao}{DAO module handling migration state deletion}{delete-dao.hs}

The result of the database action is converted into \gls{http} status code and returned to the client application with empty body.

\subsubsection*{Client-side implementation}

The client application offers user to cancel migration only in case, where the server sent questionnaire data with appropriate flag (as shown in wireframe \ref{fig:wf5}).
When the user choose to cancel the migration, the application sends request to the server.
Once the server reposponds to the request, list of questionnaires is reloaded to correspond with latest state available at server.

\subsection{Create migration context}

The migration context is a feature, where user is able to see changes occured in between current and target version of the knowledge model.
The context is made from knowledge model events, which are visualized in context of the filled questionnaire.
Therefore, the migration context is only done on the client side of the application -- the only purpose of server for this action is to provide the current migration state.

\subsubsection*{Server-side implementation}

For the migration state, the server needs to create \textit{diff knowledge model}
Diff knowledge model contains nodes from the newer version together with nodes which were only available in previous version and were deleted during customization.

Such knowledge model is created using specialized module called \texttt{KnowledgeModelDiffService}.
This service module expose functionality to create diff knowledge model by giving original and target knowledge models identifiers.

The service will compile original knowledge model and finds all events occured up until the target version.
After that, specialized version of knowledge model compiler is called to create the diff knowledge model.
The custom compiler main task is to remove all destructing events and running the standard compiler as shown in example \ref{code:custom-compiler}.

Once the knowledge is compiled, it enriches the response to the client application.

\hscode{code:custom-compiler}{Diff knowledge model compiler}{custom-compiler.hs}

\subsubsection*{Client-side implementation}

On the client side, the making the context is more complex.
There are three structures which needs to be created and maintained, it is:

\begin{itemize}
    \item \texttt{DiffTree},
    \item \texttt{DiffStates},
    \item \texttt{DiffEventsUuids}.
\end{itemize}

As mentioned in section \ref{sec:questionnaire-overview}, the first two structures are incompatible and therefore the third structure is used to map between them.

The \texttt{DiffTree} is used to create overview of the whole questionnaire structure (with all possible questions and answers) by also taking the user's answers into account.

Structure is built on top of the customly created knowledge model, called diff knowledge model.

Once the client application downloads the migration state, it starts building the mentioned structures.
The first one created is \texttt{DiffTree}.
The tree is created by recursively browsing knowledge model nodes as shown in example \ref{code:diff-tree}.

\elmcode{code:diff-tree}{Recursive initialization of the questionnaire tree (simplified)}{diff-tree.elm}

Once the tree is created, the diff events are transformed into internal representation to build the \texttt{DiffStates} structure.
Because the \texttt{DiffState} is used to show both original and new state, the transfromation needs not only the event as an input, but also both versions of the knowledge model.
While transforming events, there is no information about the hierarchical classification of the node.
Therefore this structure can not be directly mapped to the tree structure and can not take in to account user's replies.
The example of transforming events into \texttt{DiffState}s is shown in example \ref{code:transform-events}.

\elmcode{code:transform-events}{Transforming knowledge model events into diff state}{transform-events.elm}

The last structure used to create questionnaire overview is \texttt{DiffEventsUuids}.
This structure is build after the previous one because its content is used to quickly search diff state nodes for the overview tree and vice versa.
It is created by visiting every node in \texttt{DiffTree} and looking up its unique identifier in \texttt{DiffState}, when the node is found in of both these structures, it is inserted into collection.
This way, there will be multiple records for item templates question type if user replied multiple time.
Such behavior is intentional and correct by design.
The illustration \ref{fig:mapping-structure} shows how the mentioned data structures are connected.

\image[0.8\textwidth]{fig:mapping-structure}{Mapping between tree structure and diff events}{mapping-structure.pdf}

\subsection{Update migrated questionnaire state}

Updating questionnaire state allows user to add flags to questions which are listed in list of diff events.

\subsubsection*{Server-side implementation}

On the server side, the only responsibility is to persist given flags.
As there might be more flags in the future with different entitlements for consistency, the server does not run any validations on flags provided from the client application.
Currently, the whole consistency is managed on the client application only.

Once the provided data from the client are successfully deserialized, it replaces the current flags for given question and are stored in questionnaire in migration state.

\subsubsection*{Client-side implementation}

The client application allows to modify question state only when the question is listed in list of events and has default state (no flags).
To do so, the application only shows the \textit{resolved} and \textit{needs review} buttons when the question state was not modified previously.
In other case, the application renders an \textit{undo} button instead to allow user to return question to the default state.

The state is synchronized immediately when user presses appropriate button.
Once the state change is synchronized with the server, it is also updated locally (without fetching data from server).
The local update forces application to rerender the whole screen (in the sense of virtual \gls{dom}) which leads to switching action buttons for undo action and vice versa.

The application also allows the user to add flags to system answers (for item templates or single choice answers).
This, however, internally flags question instead of answer bacause the quetionnaire \gls{ui} does not support previews of answers only.

\subsection{Finalize migration}

Finilizing the migration is the last step to upgrade the questionnaire knowledge model version.

\subsubsection*{Server-side implementation}

Once the client requests to finalize the migration, server needs to do following tasks:

\begin{enumerate}
    \item create new questionnaire with migrated answers,
    \item delete the migration state.
\end{enumerate}

The first step ensures, that new questionnaire is created alongside the original one.
Together with questionnaire, replies and question flags are copied.

The second step reverts the original questionnaire into original state (can be migrated again).
Once the migration is finished, user's list of questionnaire will contain the new questionnaire alongside the orginal.

The \gls{api} endpoint is available at \route{PUT /questionnaires/:qtnUuid/migrations} and returns empty body with appropriate \gls{http} status code.

\subsubsection*{Client-side implementation}

The client application use similar approach as with initializing or finalizing the migration.
The user initiates system action (\texttt{Message}, in Elm terminology) which is followed by creating an \gls{api} request to the server.

The action s initiated from migration detail.
Once the server responds, the application redirects user to the list of questionnaires.
After the redirect, application will fetch the latest version of the questionnaires and user will the newer version display alongside the original one.
