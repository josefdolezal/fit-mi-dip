\section{Class diagram}\label{sec:class-diagram}

In this section, I will introduce the class diagram for both the \textit{DSW Server} and the \textit{DSW Client} applications.
This diagram is pratially based on the current state and outcomes of the analysis in chapter \ref{cptr:analysis}.

The diagram is split in to two parts -- one for the server side and one for the client side.
Main entities are then further described for better understanding of the design.

\subsection{Class diagram in context of functional programming}

In functional programming, generally used term \texttt{class} is either not used at all or (in case of Haskell, for example) has completely different meaning.
This, though, does not mean that complex data structures are not used.

Both Haskell and Elm programming languages have concept of structured data called either \texttt{data} (in Haskell) or \texttt{type} (in Elm).
These structures, however, does not encapsulated internal state and lack of methods.

To maintain consistency with terms used in context of software engineering, I decided to use generally know terms such as \textit{class diagram}.
For such terms, user should always refer to this section to avoid misunderstanding.

\subsection{Server class diagram}

Firstly I would like to introduce class diagram for the server application.
The diagram is shown in figure \ref{fig:srv-class-diagram}.
Entities on the left side the diagram are either newly introduced or existing entities which needed to be updated.
On the right side of the diagram, there are entities (partialy transparent) which were used in the solution but were not modified, thus serves only for completenes of the diagram.

\image{fig:srv-class-diagram}{Server class diagram}{server-class-diagram.pdf}

\subsubsection*{QuestionnaireMigrationState}

This entity is used designed to hold state of the migration.
It contains deep copy of the migrated questionnaire and an identifier of target knowledge model.

Initilly, this entity was design to also contain deep copy of both old and new version of the knowledge model.
The maintaining team of the \gls{dsw} however removed knowledge model caching feature so knowledge models are always compiled from scratch\cite{gh-dsw-release-1.5}.

Therefore, the all needed knowledge models are referred to only using unique identifiers.

The state of the migrated question was added to questionnaire itself as the state needs to be preserved also once the migration is completed.
The deep copy of the questionnaire is then used to create new copy of the questionnaire without modifying the orginal version.

\subsubsection*{QuestionnaireState}

Questionnaire state is a simple enumeration of three basic cases:

\begin{itemize}
    \item \texttt{Default},
    \item \texttt{Migrating},
    \item \texttt{Outdated}.
\end{itemize}

The \texttt{Default} state represents cases, where questionnaire is based on the latest version of the knowledge model (and no migration is therefore available).
Once the user creates a migration for a questionnaire, it is moved into \texttt{Migrating} state and preserev in such state until the migration is either finish or canceled.

The last possible state represents a questionnaire, which is based on an older version of the knowledge model and can be migrated to the newer one.

\subsubsection*{QuestionFlags}

Question flags represents state of migrated questions.
Questionnaire holds a collection of \texttt{QuestionFlags} object, which is composed from question unique identifier and an set question flags (represented by \texttt{QuestionFlagType.}).

Currently, at most one flag is allowed to be added to each question.
\texttt{QuestionFlags} is however designed to keep arbitrary number of flags.

This makes such feature future proof as more flag types may be easily added later.
On the other hand, such feature requires more complex management of the flags because integration constraints.

\subsubsection*{QuestionFlagType}

This enumeration represents all possible types of migrated question state.
Currently, only two cases are implemented: \texttt{NeedsReview} and \texttt{Resolved}.

These cases corresponds to states identified in functional requirements in section \ref{sec:functional-requirements}.
As described in previous section, these cases are currently mutually exclusive, therefore additional business logic needs to keep data consistent.

\subsection{Client class diagram}
